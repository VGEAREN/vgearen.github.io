{"pages":[],"posts":[{"title":"CGLib动态代理","text":"Spring AOP的原理是 JDK 动态代理和CGLIB字节码增强技术，前者需要被代理类实现相应接口，也只有接口中的方法可以被JDK动态代理技术所处理；后者实际上是生成一个子类，来覆盖被代理类，那么父类的final方法就不能代理，因为父类的final方法不能被子类所覆盖。一般而言Spring默认优先使用JDK动态代理技术，只有在被代理类没有实现接口时，才会选择使用CGLIB技术来实现AOP。 CGLib动态代理要点： 代理过程在MethodInterceptor.invoke中 通过Enhancer来创建代理对象 编写被代理类12345678910public class Chinese{ public String doEat(String food) { return food; } public int showAge(int age) { return 18; }} 编写代理类123456789101112public class CGLibAction implements MethodInterceptor { private Object instance; public CGLibAction(Object instance) { this.instance = instance; } @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { objects[0] = &quot;Use chopsticks to eat &quot; + objects[0]; return method.invoke(this.instance,objects); }} 创建代理实例12345678public class CGLibTest { public static void main(String[] args) { Chinese chinese = new Chinese(); Enhancer enhancer = new Enhancer(); Chinese action = (Chinese) enhancer.create(Chinese.class, new CGLibAction(chinese)); System.out.println(action.doEat(&quot;seafood&quot;)); }} 其中创建代理方法org.springframework.cglib.proxy.Enhancer#create定义： org.springframework.cglib.proxy.Enhancer#create(java.lang.Class, org.springframework.cglib.proxy.Callback) 创建拦截对象的辅助方法。 为了更好地控制生成的实例，请使用Enhancer的新实例而不是此静态方法。 参数：type - 要扩展的类或要实现的接口callback – 用于所有方法的回调 实现的MethodInterceptor 就是Callback的子类： public interface MethodInterceptor extends Callback 运行一下，得到结果： 123Use chopsticks to eat seafoodProcess finished with exit code 0","link":"/2021/12/12/CGLib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"title":"CentOS7 Firewall常用命令汇总","text":"1、firewalld启停 1234567891011# 启动systemctl start firewalld # 查看状态systemctl status firewalld # 下次不会开机启动systemctl disable firewalld # 关闭systemctl stop firewalld 2、常用操作 1234567891011121314# 添加端口firewall-cmd --zone=public --add-port=80/tcp --permanent # 重新载入 firewall-cmd --reload # 查看端口 firewall-cmd --zone=public --query-port=80/tcp # 删除端口 firewall-cmd --zone=public --remove-port=80/tcp --permanent # 查看所有打开的端口firewall-cmd --zone=public --list-ports","link":"/2021/10/19/CentOS7-Firewall%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"},{"title":"IDEA中类图表示","text":"实现关系(Realization)implements 12345678910public interface User { void getUserName();}public class UserImpl implements User { @Override public void getUserName() { return; }} 泛化关系(Generalization)extends 123public class AdminUser extends UserImpl{} 依赖关系（Dependency）1234567891011121314151617181920212223242526272829303132333435363738394041public class Person { public void method1() { //A依赖于B的第一种表现形式：B为A的局部变量 Person1 person1 = new Person1(); person1.method1(); } public void method2() { //A依赖于B的第二种表现形式： 调用B的静态方法 Person2.method2(); } public void method3(Person3 person3) { //A依赖于B的第三种表现形式：B作为A的方法参数 String s = person3.field1; } //A依赖于B的第四种表现形式：B作为A的方法的返回值 public Person5 method4() { return new Person5(); }}public class Person1{ public void method1(){ }}public class Person2 { public static void method2(){ }}public class Person3 { public String field1;}public class Person5 {} 关联关系(Association)单向关联 123456public class Person { private IDcard iDcard;}public class IDcard {} 双向关联 1234567public class Person { private IDcard iDcard;}public class IDcard { private Person person;} 也可以一对多 1234567public class Person { private List&lt;IDcard&gt; iDcard;}public class IDcard {} 聚合关系 (Aggregation)12345678910111213public class Department { private List&lt;Staff&gt; staff; public List&lt;Staff&gt; getStaff() { return staff; } }public class Staff {}","link":"/2021/12/14/IDEA%E4%B8%AD%E7%B1%BB%E5%9B%BE%E8%A1%A8%E7%A4%BA/"},{"title":"IDEA快捷键速查","text":"Ctrl 快捷键 介绍 Ctrl + F 在当前文件进行文本查找 （必备） Ctrl + R 在当前文件进行文本替换 （必备） Ctrl + Z 撤销 （必备） Ctrl + Y 删除光标所在行 或 删除选中的行 （必备） Ctrl + X 剪切光标所在行 或 剪切选择内容 Ctrl + C 复制光标所在行 或 复制选择内容 Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备） Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备） Ctrl + E 显示最近打开的文件记录列表 （必备） Ctrl + N 根据输入的 类名 查找类文件 （必备） Ctrl + G 在当前文件跳转到指定行处 Ctrl + J 插入自定义动态代码模板 （必备） Ctrl + P 方法参数提示显示 （必备） Ctrl + Q 光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容 Ctrl + U 前往当前光标所在的方法的父类的方法 / 接口定义 （必备） Ctrl + B 进入光标所在的方法/变量的接口或是定义处，等效于 Ctrl + 左键单击 （必备） Ctrl + K 版本控制提交项目，需要此项目有加入到版本控制才可用 Ctrl + T 版本控制更新项目，需要此项目有加入到版本控制才可用 Ctrl + H 显示当前类的层次结构 Ctrl + O 选择可重写的方法 Ctrl + I 选择可继承的方法 Ctrl + + 展开代码 Ctrl + - 折叠代码 Ctrl + / 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备） Ctrl + [ 移动光标到当前所在代码的花括号开始位置 Ctrl + ] 移动光标到当前所在代码的花括号结束位置 Ctrl + F1 在光标所在的错误代码处显示错误信息 （必备） Ctrl + F3 调转到所选中的词的下一个引用位置 （必备） Ctrl + F4 关闭当前编辑文件 Ctrl + F8 在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点 Ctrl + F9 执行 Make Project 操作 Ctrl + F11 选中文件 / 文件夹，使用助记符设定 / 取消书签 （必备） Ctrl + F12 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选 Ctrl + Tab 编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口 Ctrl + End 跳到文件尾 Ctrl + Home 跳到文件头 Ctrl + Space 基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备） Ctrl + Delete 删除光标后面的单词或是中文句 （必备） Ctrl + BackSpace 删除光标前面的单词或是中文句 （必备） Ctrl + 1,2,3...9 定位到对应数值的书签位置 （必备） Ctrl + 左键单击 在打开的文件标题上，弹出该文件路径 （必备） Ctrl + 光标定位 按 Ctrl 不要松开，会显示光标所在的类信息摘要 Ctrl + 左方向键 光标跳转到当前单词 / 中文句的左侧开头位置 （必备） Ctrl + 右方向键 光标跳转到当前单词 / 中文句的右侧开头位置 （必备） Ctrl + 前方向键 等效于鼠标滚轮向前效果 （必备） Ctrl + 后方向键 等效于鼠标滚轮向后效果 （必备） Alt 快捷键 介绍 Alt + ` 显示版本控制常用操作菜单弹出层 （必备） Alt + Q 弹出一个提示，显示当前类的声明 / 上下文信息 Alt + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择 （必备） Alt + F2 对于前面页面，显示各类浏览器打开目标选择弹出层 Alt + F3 选中文本，逐个往下查找相同文本，并高亮显示 Alt + F7 查找光标所在的方法 / 变量 / 类被调用的地方 Alt + F8 在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果 Alt + Home 定位 / 显示到当前文件的 Navigation Bar Alt + Enter IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备） Alt + Insert 代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等 （必备） Alt + 左方向键 切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 （必备） Alt + 右方向键 按切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 （必备） Alt + 前方向键 当前光标跳转到当前文件的前一个方法名位置 （必备） Alt + 后方向键 当前光标跳转到当前文件的后一个方法名位置 （必备） Alt + 1,2,3...9 显示对应数值的选项卡，其中 1 是 Project 用得最多 （必备） Shift 快捷键 介绍 Shift + F1 如果有外部文档可以连接外部文档 Shift + F2 跳转到上一个高亮错误 或 警告位置 Shift + F3 在查找模式下，查找匹配上一个 Shift + F4 对当前打开的文件，使用新Windows窗口打开，旧窗口保留 Shift + F6 对文件 / 文件夹 重命名 Shift + F7 在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法 Shift + F8 在 Debug 模式下，跳出，表现出来的效果跟 F9 一样 Shift + F9 等效于点击工具栏的 Debug 按钮 Shift + F10 等效于点击工具栏的 Run 按钮 Shift + F11 弹出书签显示层 （必备） Shift + Tab 取消缩进 （必备） Shift + ESC 隐藏当前 或 最后一个激活的工具窗口 Shift + End 选中光标到当前行尾位置 Shift + Home 选中光标到当前行头位置 Shift + Enter 开始新一行。光标所在行下空出一行，光标定位到新行位置 （必备） Shift + 左键单击 在打开的文件名上按此快捷键，可以关闭当前打开文件 （必备） Shift + 滚轮前后滚动 当前文件的横向滚动轴滚动 （必备） Ctrl + Alt 快捷键 介绍 Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用。（有些文件格式化是有特殊要求的，比如 SQL 文件必须设置方言才可被格式化） （必备） Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用 （必备） Ctrl + Alt + I 光标所在行 或 选中部分进行自动代码缩进，有点类似格式化 Ctrl + Alt + T 对选中的代码弹出环绕选项弹出层 （必备） Ctrl + Alt + J 弹出模板选择窗口，将选定的代码加入动态模板中 Ctrl + Alt + H 调用层次 Ctrl + Alt + B 在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口 Ctrl + Alt + C 重构-快速提取常量 Ctrl + Alt + F 重构-快速提取成员变量 Ctrl + Alt + V 重构-快速提取变量 Ctrl + Alt + Y 同步、刷新 Ctrl + Alt + S 打开 IntelliJ IDEA 系统设置 （必备） Ctrl + Alt + F7 显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来 Ctrl + Alt + F11 切换全屏模式 Ctrl + Alt + Enter 光标所在行上空出一行，光标定位到新行 （必备） Ctrl + Alt + Home 弹出跟当前文件有关联的文件弹出层 Ctrl + Alt + Space 类名自动完成 Ctrl + Alt + 左方向键 退回到上一个操作的地方 （必备） Ctrl + Alt + 右方向键 前进到上一个操作的地方 （必备） Ctrl + Alt + 前方向键 在查找模式下，跳到上个查找的文件 Ctrl + Alt + 后方向键 在查找模式下，跳到下个查找的文件 Ctrl + Alt + 右括号（]） 在打开多个项目的情况下，切换下一个项目窗口 Ctrl + Alt + 左括号（[） 在打开多个项目的情况下，切换上一个项目窗口 Ctrl + Shift 快捷键 介绍 Ctrl + Shift + F 根据输入内容查找整个项目 或 指定目录内文件 （必备） Ctrl + Shift + R 根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备） Ctrl + Shift + J 自动将下一行合并到当前行末尾 （必备） Ctrl + Shift + Z 取消撤销 （必备） Ctrl + Shift + W 递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备） Ctrl + Shift + N 通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备） Ctrl + Shift + U 对选中的代码进行大 / 小写轮流转换 （必备） Ctrl + Shift + T 对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 （必备） Ctrl + Shift + C 复制当前文件磁盘路径到剪贴板 （必备） Ctrl + Shift + V 弹出缓存的最近拷贝的内容管理器弹出层 Ctrl + Shift + E 显示最近修改的文件列表的弹出层 Ctrl + Shift + H 显示方法层次结构 Ctrl + Shift + B 跳转到类型声明处 （必备） Ctrl + Shift + I 快速查看光标所在的方法 或 类的定义 Ctrl + Shift + A 查找动作 / 设置 Ctrl + Shift + / 代码块注释 （必备） Ctrl + Shift + [ 选中从光标所在位置到它的顶部中括号位置 （必备） Ctrl + Shift + ] 选中从光标所在位置到它的底部中括号位置 （必备） Ctrl + Shift + + 展开所有代码 （必备） Ctrl + Shift + - 折叠所有代码 （必备） Ctrl + Shift + F7 高亮显示所有该选中文本，按Esc高亮消失 （必备） Ctrl + Shift + F8 在 Debug 模式下，指定断点进入条件 Ctrl + Shift + F9 编译选中的文件 / 包 / Module Ctrl + Shift + F12 编辑器最大化 （必备） Ctrl + Shift + Space 智能代码提示 Ctrl + Shift + Enter 自动结束代码，行末自动添加分号 （必备） Ctrl + Shift + Backspace 退回到上次修改的地方 （必备） Ctrl + Shift + 1,2,3...9 快速添加指定数值的书签 （必备） Ctrl + Shift + 左键单击 把光标放在某个类变量上，按此快捷键可以直接定位到该类中 （必备） Ctrl + Shift + 左方向键 在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句 （必备） Ctrl + Shift + 右方向键 在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句 （必备） Ctrl + Shift + 前方向键 光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 （必备） Ctrl + Shift + 后方向键 光标放在方法名上，将方法移动到下一个方法前面，调整方法排序 （必备） Alt + Shift 快捷键 介绍 Alt + Shift + N 选择 / 添加 task （必备） Alt + Shift + F 显示添加到收藏夹弹出层 / 添加到收藏夹 Alt + Shift + C 查看最近操作项目的变化情况列表 Alt + Shift + I 查看项目当前文件 Alt + Shift + F7 在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入 Alt + Shift + F9 弹出 Debug 的可选择菜单 Alt + Shift + F10 弹出 Run 的可选择菜单 Alt + Shift + 左键双击 选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 （必备） Alt + Shift + 前方向键 移动光标所在行向上移动 （必备） Alt + Shift + 后方向键 移动光标所在行向下移动 （必备） Ctrl + Shift + Alt 快捷键 介绍 Ctrl + Shift + Alt + V 无格式黏贴 （必备） Ctrl + Shift + Alt + N 前往指定的变量 / 方法 Ctrl + Shift + Alt + S 打开当前项目设置 （必备） Ctrl + Shift + Alt + C 复制参考信息 其他 快捷键 介绍 F2 跳转到下一个高亮错误 或 警告位置 （必备） F3 在查找模式下，定位到下一个匹配处 F4 编辑源 （必备） F7 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 F8 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 F9 在 Debug 模式下，恢复程序运行，直至下个断点或程序运行结束 F11 添加书签 （必备） F12 回到前一个工具窗口 （必备） Tab 缩进 （必备） ESC 从工具窗口进入代码文件窗口 （必备） 连按两次Shift 弹出 Search Everywhere 弹出层","link":"/2022/01/27/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%80%9F%E6%9F%A5/"},{"title":"IDEA插件修改","text":"简介有时候需要用到某些IDEA插件的高级功能，使用次数不高，但是高级版需要收费，因此对插件进行一些小修改，这里记录一下修改思路，具体修改的插件就不写了，避免不必要的麻烦。这里记录的方法仅供学习使用，如果有能力建议还是支持正版。 环境&amp;工具由于有时候插件作者为了使插件不容易被破解，可能会假如混淆，但是Windows系统使不区分大小写的，这样操作Jar包会造成错误，所以还需要准备Linux环境，其他软件： 1、JEB Decompiler Professional 3.19.1、recaf、jd-gui：反编译jar包，查看代码 2、Java ByteCode Editor：修改字节码 过程 1、IDEA的插件位于%appdata%\\JetBrains\\IntelliJIdea2021.1\\plugins中间的文件夹根据自己的IDEA版本自行替换一下 2、找到需要破解的插件，里面可能有多个jar包，首先排除掉依赖的jar包，找到其中需要破解的jar，使用JD-GUI或者JEB打开 以下步骤可能每个插件破解方式都不一样，这里只是阐述这个插件的破解过程和思路 3、用jd-gui打开jar包，软件激活的按钮是Activation,在META-INF/plugin.xml中搜索Activation然后可以找到这句：1&lt;action id=&quot;xxx.offlineActivation&quot; class=&quot;com.ccnode.codegenerator.O.N&quot; text=&quot;Activation&quot; description=&quot;Activation&quot;/&gt; 4、JEB进入到类com.ccnode.codegenerator.O.N里面 123456public final class N extends AnAction { public void actionPerformed(@NotNull AnActionEvent arg3) { Intrinsics.checkParameterIsNotNull(((Object)arg3), &quot;e&quot;); new a(arg3.getProject()).showAndGet(); } } 5、new a()这个函数想必就是节目的视图层了，看看a()中的代码看看有没有地方可以下手： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private void d() { int v1 = a.e(); com.ccnode.codegenerator.D.a.c v0 = com.ccnode.codegenerator.D.a.b.a(); try { this.m.setEditable(false); if(v1 == 0) { boolean v2 = v0.b().booleanValue(); //此处也需要返回true goto label_16; } else { goto label_64; } return; } catch(TypeCastException v0_1) { throw a.b(((Exception)v0_1)); } label_16: if(!v2) { goto label_49; } this.m.setForeground(new Color(46, 204, 0x71)); this.m.setText(aw.c(v0.c())); this.g.setVisible(true); String v0_2 = v0.a(); if(v1 == 0) { try { int v2_1 = v0_2.length(); } catch(TypeCastException v0_3) { throw a.b(((Exception)v0_3)); } if(v2_1 == 36) { v0_2 = StringUtils.abbreviateMiddle(v0_2, &quot;****&quot;, 35); } this.s.setText(v0_2); this.s.setForeground(new Color(46, 204, 0x71)); } if(v1 != 0) { try { label_49: this.m.setForeground(Color.RED); this.m.setText(&quot;not activated yet&quot;); } catch(TypeCastException v0_4) { throw a.b(((Exception)v0_4)); } this.g.setVisible(false); return; label_64: this.g.setVisible(false); }} 这里我们看到一个函数，this.m.setText(&quot;not activated yet&quot;);根据这一句的判断逻辑，再去到com.ccnode.codegenerator.D.a.b.a(); 6、com.ccnode.codegenerator.D.a.b.a()函数可以再去到com.ccnode.codegenerator.W.d.c() 1234567891011121314151617181920212223 public static c a() { com.ccnode.codegenerator.W.d.c v0 = new com.ccnode.codegenerator.W.d.c(); v0.a(&quot;xxx&quot;); v0.c(a_.a()); boolean v1 = m.a(v0); d.a().setValid(v1); c v2 = new c(); new String(&quot;M18b9&quot;); v2.a(Boolean.valueOf(v1)); v2.a(v0.c()); v2.a(v0.d()); try { if(DomainObject.b() != null) { b.b(&quot;KLGaO&quot;); return v2; } } catch(TypeCastException v0_1) { throw b.a(v0_1); } return v2;} 7、进到com.ccnode.codegenerator.W.d.c()这个实体类基本就比较明朗了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class c {@SerializedName(&quot;valid&quot;)private boolean a;@SerializedName(&quot;paidKey&quot;)private String b;private static final String[] bb;@SerializedName(&quot;returnExpireDate&quot;)private Date c;private static final String[] cb;@SerializedName(&quot;userPluginName&quot;)@NotNullprivate String d;@SerializedName(&quot;userMac&quot;)private String e; public void a(String arg1) { this.d = arg1; } public void a(Date arg1) { this.c = arg1; } public void a(boolean arg1) { this.a = arg1; } public boolean a() { return this.a; } public String b() { return this.e; } public void b(String arg1) { this.b = arg1; } public Date c() { return this.c; } public void c(String arg1) { this.e = arg1; } public String d() { return this.b; } public String e() { return this.d; }} 这里就很简单了，只需要让实体类直接返回我们指定的值就行了，更改其中的String e()、 Date c()、 boolean a()、String d()、 String b() 8、下面讲一下怎么使用 jbe 打开字节码并修改； 1、在linux中解压jar包并取出com.ccnode.codegenerator.W.d.c -&gt; c.class使用 jbe 打开 2、我现在要修改boolean a()这个函数，使它能直接返回true 3、在 jbe 中点击Methods，找到a函数，有好几个a函数，找入参返回值符合boolean a()的 123Name: cp_info #35 &lt;a&gt;Discriptor: cp_info #48 &lt;() Z&gt;Access flags: 0x0001[public] 4、由于我对字节码不是很熟悉，所以我直接写好相关函数，然后编译出class，直接复制过来覆盖。123public boolean a() { return true;} 在IDEA中编译后再通过插件jclasslib查看字节码:120 iconst_11 ireturn 直接复制到 jbe 的Code Editor中，保存。Misc中的Maximum stack depth和 Maximum local variables也同步更改一下 5、同理替换其他函数 9、修改完之后，linux中将class文件放在com/ccnode/codegenerator/W/d/下，jar包放在com同级目录: 1jar uvf test.jar com/ccnode/codegenerator/W/d/c.class 10、将jar包放回原来的目录中，打包成zip，在IDEA中重新安装一下，验证是否破解成功了。 11、这里还需要更改一个地方boolean v2 = v0.b().booleanValue(); ，v0.b()这里返回true，修改方法和上面一样，到这里就修改结束了。","link":"/2021/09/13/IDEA%E6%8F%92%E4%BB%B6%E4%BF%AE%E6%94%B9/"},{"title":"JAVA注解的底层实现","text":"前言注解的声明如下： {InterfaceModifier} @interface Identifier AnnotationTypeBody接口修饰符 @interface 注解标识符 注解类型的内容 根据类图，我们可以知道每个注解的父接口都是java.lang.annotation.Annotation。 底层实现先定义一个注解： 123456789101112131415161718192021222324# AnnotationTest.java@Retention(RetentionPolicy.RUNTIME)@Documented@Target(ElementType.TYPE)public @interface AnnotationTest { String value() default &quot;some test&quot;;}# Person.java@AnnotationTest(&quot;person test&quot;)public class Person {}# Test.javapublic class Test { public static void main(String[] args) {-&gt; Annotation[] declaredAnnotations = Person.class.getDeclaredAnnotations(); // 在这里打断点debug一下 for (Annotation declaredAnnotation:declaredAnnotations){ String name = declaredAnnotation.getClass().getName(); System.out.println(name); } }} AnnotatedElement这里先简单介绍下AnnotatedElement ，如果看到后面对某个函数不懂可以倒回来看这里： AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息。我们看下具体的先关接口 boolean isAnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass) 判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。注意：此方法会忽略注解对应的注解容器。 &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) 返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。 Annotation[] getAnnotations() 返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。 &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass) 返回该程序元素上存在的、指定类型的注解数组。没有注解对应类型的注解时，返回长度为0的数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。getAnnotationsByType方法与 getAnnotation的区别在于，getAnnotationsByType会检测注解对应的重复注解容器。若程序元素为类，当前类上找不到注解，且该注解为可继承的，则会去父类上检测对应的注解。 &lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotationClass) 返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注解直接存在于此元素上，则返回null &lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass) 返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注解 Annotation[] getDeclaredAnnotations() 返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注解直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。 Class.javagetDeclaredAnnotations我们进入到getDeclaredAnnotations方法中可以发现：Class.java 里面实现了java.lang.reflect.AnnotatedElement，可以通过调用Annotation[] getDeclaredAnnotations()方法获取注解： public Annotation[] getDeclaredAnnotations()的定义： 返回直接出现在此元素上的注解。 此方法忽略继承的注解。 如果该元素上没有直接存在的注解，则返回值是一个长度为 0 的数组。该方法的调用者可以自由修改返回的数组； 它不会影响返回给其他调用者的数组。 返回：直接出现在此元素上的注解自从：1.5 进入getDeclaredAnnotations方法： 1234# java.lang.Class#getDeclaredAnnotationspublic Annotation[] getDeclaredAnnotations() { return AnnotationParser.toArray(annotationData().declaredAnnotations);} 可以看到declaredAnnotations是个Map： 12# java.lang.Class.AnnotationData#declaredAnnotationsfinal Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations; 直接通过获取Map的值就可以返回注解了，这么说只要深入这个annotationData().declaredAnnotations的初始化过程，就可以知道注解是怎么初始化的了。 annotationData进入annotationData()： 123456789101112131415161718# java.lang.Class#annotationDataprivate AnnotationData annotationData() { while (true) { // retry loop AnnotationData annotationData = this.annotationData; int classRedefinedCount = this.classRedefinedCount; if (annotationData != null &amp;&amp; annotationData.redefinedCount == classRedefinedCount) { return annotationData; } // null or stale annotationData -&gt; optimistically create new instance AnnotationData newAnnotationData = createAnnotationData(classRedefinedCount); // try to install it if (Atomic.casAnnotationData(this, annotationData, newAnnotationData)) { // successfully installed new AnnotationData return newAnnotationData; } }} 进来先获取annotationData如果存在的话直接返回，没有的话通过createAnnotationData创建。 123456789101112131415private static class AnnotationData { final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations; final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations; // Value of classRedefinedCount when we created this AnnotationData instance final int redefinedCount; AnnotationData(Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations, Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations, int redefinedCount) { this.annotations = annotations; this.declaredAnnotations = declaredAnnotations; this.redefinedCount = redefinedCount; }} AnnotationData有三个常量，annotations和declaredAnnotations都是Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt;，key为注解的注解类型，value实际上是该注解的代理实例： annotations：所有注解包括继承的注解 declaredAnnotations： 作用于此元素上的注解 redefinedCount： classRedefinedCount用于判断AnnotationData是否过时 这个方法有另外一个知识点，CAS（Compare And Swap）,即比较并替换，实现并发算法时常用到的一种技术。 createAnnotationData进入createAnnotationData，代码太长了就不贴了，这个方法主要做的事情： 获取类本身的Annotations（declaredAnnotations） 如果父类不为空，获取父类的Annotations（superAnnotations） 将两个Annotations塞入Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations返回 好了，继续来看怎么获取注解，可以看到是通过AnnotationParser.parseAnnotations获取： 123# java.lang.Class#createAnnotationDataMap&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations = AnnotationParser.parseAnnotations(getRawAnnotations(), getConstantPool(), this); AnnotationParser.javaAnnotationParser是个啥呢？ Java 编程语言注解的解析器。 将编译器发出的注解字节流翻译成注解对象。 parseAnnotationsAnnotationParser.parseAnnotations又是干啥的呢？ 解析由指定字节数组描述的注解。 解析指定常量池中的常量引用。 该数组必须包含一个注解数组，如 RuntimeVisibleAnnotations_attribute 中所述： ​ u2 num_annotations; ​ annotation annotations[num_annotations]; 抛出：AnnotationFormatError – 如果发现注解格式错误 1234567891011121314151617# sun.reflect.annotation.AnnotationParser#parseAnnotationspublic static Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; parseAnnotations( byte[] rawAnnotations, ConstantPool constPool, Class&lt;?&gt; container) { if (rawAnnotations == null) return Collections.emptyMap(); try { return parseAnnotations2(rawAnnotations, constPool, container, null); } catch(BufferUnderflowException e) { throw new AnnotationFormatError(&quot;Unexpected end of annotations.&quot;); } catch(IllegalArgumentException e) { // Type mismatch in constant pool throw new AnnotationFormatError(e); }} getRawAnnotations()和getConstantPool()都是native方法：getRawAnnotations：获取自定义注解类型的字节码getConstantPool：获取this.Class的常量池，因为它里面有注解属性值 然后是sun.reflect.annotation.AnnotationParser#parseAnnotations2 ​ –&gt; `sun.reflect.annotation.AnnotationParser#parseAnnotation2(和上面的不是同一个方法！) parseAnnotations2主要是将parseAnnotation2返回的注解类塞进Map里，然后一起返回 parseAnnotation2而parseAnnotation2的作用是 将从之前两个native方法（getRawAnnotations()和getConstantPool()）中获取注解类 获取注解的参数，注解的参数也是存在this.Class的常量池中，如果为空则取注解默认值 然后把获取到的注解类及注解参数传给annotationForMap。 annotationForMap12345678910public static Annotation annotationForMap(final Class&lt;? extends Annotation&gt; type, final Map&lt;String, Object&gt; memberValues){ return AccessController.doPrivileged(new PrivilegedAction&lt;Annotation&gt;() { public Annotation run() { return (Annotation) Proxy.newProxyInstance( type.getClassLoader(), new Class&lt;?&gt;[] { type }, new AnnotationInvocationHandler(type, memberValues)); }});} 最后到annotationForMap，通过入参的注解类及注解参数创建JDK动态代理实例返回，其中AnnotationInvocationHandler是用于 Annotation 的动态代理实现。 123public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 返回指定接口的代理类的实例，该接口将方法调用分派到指定的调用处理程序。Proxy.newProxyInstance抛出IllegalArgumentException的原因与Proxy.getProxyClass相同。 参数：loader – 定义代理类的类加载器 interfaces- 代理类要实现的接口列表 ​ h – 将方法调用分派到的调用处理程序返回：具有代理类的指定调用处理程序的代理实例，该代理类由指定的类加载器定义并实现指定的接 总结注解的底层实现就是JDK动态代理，JDK通过java.lang.reflect.AnnotatedElement接口实现对注解的解析。","link":"/2021/12/11/JAVA%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"},{"title":"JDK动态代理","text":"大家都知道，接口是不能实例化的，除非实现了该接口，那有没有什么办法，不编写实现类，创捷接口实例呢？ 答案是有的，通过JDK动态代理，创建JDK动态代理有几个条件： 创建代理对象时需要实现InvocationHandler 代理过程在invoke中实现 下面就通过代码来实现一下： 代理接口方法定义接口12345public interface Human { String doEat(String food); int showAge(int age);} 编写代理方法12345678910111213141516171819public class ActionProxy implements InvocationHandler { private Object instance; public ActionProxy(Object instance){ this.instance = instance; } public ActionProxy(){ } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method.getName()); for (Object arg : args) { System.out.println(arg); } return null; }} 我们在invoke把方法名和参数打印一下 创建代理实例12345public static void main(String[] args) { Human proxyInstance = (Human) Proxy.newProxyInstance(Human.class.getClassLoader(), new Class[]{Human.class}, new ActionProxy()); proxyInstance.doEat(&quot;apple&quot;); //proxyInstance.showAge(50);} 运行一下输出 12doEatapple 调用没问题，但是这里有个点需要注意，接口还定义了一个showAge方法，返回int，但是我们的invoke中返回的是null，如果我们调用showAge，就会报NullPointerException: 12345showAge50Exception in thread &quot;main&quot; java.lang.NullPointerException at com.sun.proxy.$Proxy0.showAge(Unknown Source) at com.example.javalearning.HumanTest.main(HumanTest.java:9) 我们这里可以看下invoke的定义： 处理代理实例上的方法调用并返回结果。 当在与其关联的代理实例上调用方法时，将在调用处理程序上调用此方法。 参数： proxy - 调用该方法的代理实例 method – 与在代理实例上调用的接口方法对应的Method实例。 Method对象的声明类将是该方法声明所在的接口，它可能是代理类继承该方法所 通过的代理接口的超接口。 args – 包含在代理实例的方法调用中传递的参数值的对象数组，如果接口方法不接受参数，则为null 。 原始类型的参数被包装在适当的原始包装类 的实例中，例如java.lang.Integer或java.lang.Boolean 。返回： 从代理实例上的方法调用返回的值。 如果接口方法声明的返回类型是原始类型，则该方法返回的值必须是对应的原始包装类的实例； 否则，它必 须是可分配给声明的返回类型的类型。 如果此方法返回的值为null且接口方法的返回类型为原始类型，则代理实例上的方法调用将抛出 NullPointerException 。 如果此方法返回的值与上述接口方法声明的返回类型不兼容，则代理实例上的方法调用将抛出ClassCastException 。抛出： Throwable – 从代理实例的方法调用中抛出的异常。 异常的类型必须可分配给在接口方法的throws子句中声明的任何异常类型，或分配给未经检查 的异常类型java.lang.RuntimeException或java.lang.Error 。 如果此方法抛出的已检查异常不可分配给接口方法的throws子句中声明的任何异常类 型，则包含此方法抛出的异常的UndeclaredThrowableException将被该方法上的方法调用抛出代理实例 代理接口实例当然我们也可以代理接口实例对象，我们先编写一个Human类的实现： 实现接口123456789101112public class Chinese implements Human{ @Override public String doEat(String food) { return &quot;Use chopsticks to eat &quot; + food; } @Override public int showAge(int age) { return 18; }} 编写代理方法1234567891011121314151617181920212223242526public class ActionProxy implements InvocationHandler { private Object instance; public ActionProxy(Object instance){ this.instance = instance; } public ActionProxy(){ } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if(null != this.instance){ if (method.getName().equals(&quot;doEat&quot;)){ args[0] = &quot;delicious &quot; + args[0]; Object res = method.invoke(this.instance, args); return res; }else if(method.getName().equals(&quot;showAge&quot;)){ Object res = method.invoke(this.instance, args); int i = (int)res - 10; return i; } } return null; }} 创建代理实例12345678public class HumanTest { public static void main(String[] args) { Human zhangsan = new Chinese(); Human proxyInstance = (Human) Proxy.newProxyInstance(Human.class.getClassLoader(), new Class[]{Human.class}, new ActionProxy(zhangsan)); System.out.println(proxyInstance.doEat(&quot;hot pot&quot;)); System.out.println(proxyInstance.showAge(50)); }} 运行： 12Use chopsticks to eat delicious hot pot8","link":"/2021/12/11/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"title":"Java抽象类","text":"在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。 父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。 在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。 抽象类在 Java 语言中使用 abstract class 来定义抽象类。如下实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 文件名 : Employee.java */public abstract class Employee{ private String name; private String address; private int number; public Employee(String name, String address, int number) { System.out.println(&quot;Constructing an Employee&quot;); this.name = name; this.address = address; this.number = number; } public double computePay() { System.out.println(&quot;Inside Employee computePay&quot;); return 0.0; } public void mailCheck() { System.out.println(&quot;Mailing a check to &quot; + this.name + &quot; &quot; + this.address); } public String toString() { return name + &quot; &quot; + address + &quot; &quot; + number; } public String getName() { return name; } public String getAddress() { return address; } public void setAddress(String newAddress) { address = newAddress; } public int getNumber() { return number; }} 注意到该 Employee 类没有什么不同，尽管该类是抽象类，但是它仍然有 3 个成员变量，7 个成员方法和 1 个构造方法。 现在如果你尝试如下的例子： 123456789101112/* 文件名 : AbstractDemo.java */public class AbstractDemo{ public static void main(String [] args) { /* 以下是不允许的，会引发错误 */ Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43); System.out.println(&quot;\\n Call mailCheck using Employee reference--&quot;); e.mailCheck(); }} 当你尝试编译 AbstractDemo 类时，会产生如下错误： 1234Employee.java:46: Employee is abstract; cannot be instantiated Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43); ^1 error 继承抽象类我们可以通过以下方式继承 Employee 类的属性： 123456789101112131415161718192021222324252627282930313233/* 文件名 : Salary.java */public class Salary extends Employee{ private double salary; //Annual salary public Salary(String name, String address, int number, double salary) { super(name, address, number); setSalary(salary); } public void mailCheck() { System.out.println(&quot;Within mailCheck of Salary class &quot;); System.out.println(&quot;Mailing check to &quot; + getName() + &quot; with salary &quot; + salary); } public double getSalary() { return salary; } public void setSalary(double newSalary) { if(newSalary &gt;= 0.0) { salary = newSalary; } } public double computePay() { System.out.println(&quot;Computing salary pay for &quot; + getName()); return salary/52; }} 尽管我们不能实例化一个 Employee 类的对象，但是如果我们实例化一个 Salary 类对象，该对象将从 Employee 类继承 7 个成员方法，且通过该方法可以设置或获取三个成员变量。 123456789101112131415/* 文件名 : AbstractDemo.java */public class AbstractDemo{ public static void main(String [] args) { Salary s = new Salary(&quot;Mohd Mohtashim&quot;, &quot;Ambehta, UP&quot;, 3, 3600.00); Employee e = new Salary(&quot;John Adams&quot;, &quot;Boston, MA&quot;, 2, 2400.00); System.out.println(&quot;Call mailCheck using Salary reference --&quot;); s.mailCheck(); System.out.println(&quot;\\n Call mailCheck using Employee reference--&quot;); e.mailCheck(); }} 以上程序编译运行结果如下： 123456789Constructing an EmployeeConstructing an EmployeeCall mailCheck using Salary reference --Within mailCheck of Salary classMailing check to Mohd Mohtashim with salary 3600.0Call mailCheck using Employee reference--Within mailCheck of Salary classMailing check to John Adams with salary 2400. 抽象方法如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。 Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。 抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。 12345678910public abstract class Employee{ private String name; private String address; private int number; public abstract double computePay(); //其余代码} 声明抽象方法会造成以下两个结果： 如果一个类包含抽象方法，那么该类必须是抽象类。 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。 继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。 如果Salary类继承了Employee类，那么它必须实现computePay()方法： 12345678910111213/* 文件名 : Salary.java */public class Salary extends Employee{ private double salary; // Annual salary public double computePay() { System.out.println(&quot;Computing salary pay for &quot; + getName()); return salary/52; } //其余代码} 抽象类总结规定 1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。 5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。","link":"/2021/11/30/Java%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"title":"Java类图","text":"类和类、类和接口、接口和接口之间存在一定关系，UML类图中一般会有连线指明它们之间的关系。关系共有六种类型，分别是实现关系、泛化关系、关联关系、依赖关系、聚合关系、组合关系。下面引用一下别人的图： 实现关系(Realization)很简单，就是implements 泛化关系(Generalization)泛化就是继承extends 关联关系(Association)分为单向关联和双向关联：比如有两个类，一个Person类，一个身份证IDcard类单向关联 123456class IDcard{}class Person{ private IDcard card;} 双向关联 1234567class IDcard{ private Person person;}class Person{ private IDcard card;} 依赖关系（Dependency）依赖关系是一种弱关联关系。如果对象A用到对象B，但是和B的关系不是太明显的时候，就可以把这种关系看作是依赖关系。如果对象A依赖于对象B，则 A “use a” B。比如驾驶员和汽车的关系，驾驶员使用汽车，二者之间就是依赖关系。依赖关系在Java中的具体代码表现形式为B为A的构造器或方法中的局部变量、方法或构造器的参数、方法的返回值，或者A调用B的静态方法。下面我们用代码清单1和代码清单2所示的Java代码来演示对象和对象之间的依赖关系。 代码清单1所示的B类定义了一个成员变量 field1，一个普通方法 method1() 和一个静态方法 method2()。 123456789101112//代码清单1 B.javapublic class B { public String field1; //成员变量 public void method1() { System.out.println(&quot;在类B的方法1中&quot;); } public static void method2() { //静态方法 System.out.println(&quot;在类B的静态方法2中&quot;); }} 代码清单2所示的A类依赖于B类，在A类中定义了四个方法，分别演示四种依赖形式。 1234567891011121314151617181920212223242526/* 代码清单2 A.java A依赖于B*/public class A { public void method1() { //A依赖于B的第一种表现形式：B为A的局部变量 B b = new B(); b.method1(); } public void method2() { //A依赖于B的第二种表现形式： 调用B的静态方法 B.method2(); } public void method3(B b) { //A依赖于B的第三种表现形式：B作为A的方法参数 String s = b.field1; } //A依赖于B的第四种表现形式：B作为A的方法的返回值 public B method4() { return new B(); }} 聚合关系 (Aggregation)表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。例如，公司部门与员工的关系，一个员工可以属于多个部门，一个部门撤消了，员工可以转到其它部门。 组合关系 (Composition)和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。","link":"/2021/11/30/Java%E7%B1%BB%E5%9B%BE/"},{"title":"Linux性能监控常用命令","text":"系统12345678$ uname -a # 查看内核/操作系统/CPU信息$ lsb_release -a # 查看操作系统版本 (适用于所有的linux，包括Redhat、SuSE、Debian等发行版，但是在debian下要安装lsb)$ cat /proc/cpuinfo # 查看CPU信息$ hostname # 查看计算机名$ lspci -tv # 列出所有PCI设备$ lsusb -tv # 列出所有USB设备$ lsmod # 列出加载的内核模块$ env # 查看环境变量 资源1234567$ free -m # 查看内存使用量和交换区使用量$ df -h # 查看各分区使用情况$ du -sh &lt;目录名&gt; # 查看指定目录的大小$ grep MemTotal /proc/meminfo # 查看内存总量$ grep MemFree /proc/meminfo # 查看空闲内存量$ uptime # 查看系统运行时间、用户数、负载$ cat /proc/loadavg # 查看系统负载 磁盘和分区12345$ mount | column -t # 查看挂接的分区状态$ fdisk -l # 查看所有分区$ swapon -s # 查看所有交换分区$ hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备)$ dmesg | grep IDE # 查看启动时IDE设备检测状况 网络123456$ ifconfig # 查看所有网络接口的属性$ iptables -L # 查看防火墙设置$ route -n # 查看路由表$ netstat -lntp # 查看所有监听端口$ netstat -antp # 查看所有已经建立的连接$ netstat -s # 查看网络统计信息 进程12$ ps -ef # 查看所有进程 $ top # 实时显示进程状态 用户1234567$ w # 查看活动用户$ id &lt;用户名&gt; # 查看指定用户信息$ last # 查看用户登录日志 $ cut -d: -f1 /etc/passwd # 查看系统所有用户$ cut -d: -f1 /etc/group # 查看系统所有组$ crontab -l # 查看当前用户的计划任务 服务123$ chkconfig --list # 列出所有系统服务$ chkconfig --list | grep on # 列出所有启动的系统服务 程序12 $ rpm -qa # 查看所有安装的软件包 其他123456789101112# 查看CPU信息（型号）$ cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c8 Intel(R) Xeon(R) CPU E5410 @ 2.33GHz````看到有8个逻辑CPU, 也知道了CPU型号```shell$ cat /proc/cpuinfo | grep physical | uniq -c 4 physical id : 0 4 physical id : 1 说明实际上是两颗4核的CPU 12$ getconf LONG_BIT32 说明当前CPU运行在32bit模式下, 但不代表CPU不支持64bit 12$ cat /proc/cpuinfo | grep flags | grep ' lm ' | wc -l8 结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bit 12345678910111213141516171819# 再完整看cpu详细信息, 不过大部分我们都不关心而已.$ dmidecode | grep 'Processor Information'# 查看内存信息$ cat /proc/meminfo# 查看当前操作系统内核信息$ uname -aLinux euis1 2.6.9-55.ELsmp #1 SMP Fri Apr 20 17:03:35 EDT 2007 i686 i686 i386 GNU/Linux# 查看当前操作系统发行版信息$ cat /etc/issue | grep LinuxRed Hat Enterprise Linux AS release 4 (Nahant Update 5)# 查看机器型号$ dmidecode | grep &quot;Product Name&quot;# 查看网卡信息$ dmesg | grep -i eth","link":"/2021/10/22/Linux%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"MySQL 索引概览","text":"转自：MySQL 索引概览 索引定义索引是一种专门用于帮助 SQL 高效获取数据的数据结构，一个常用的例子是，索引类似于一本书的目录，可以快速对特定值进行定位和查找，从而大大加快数据查询的效率。实际上，索引也是一张表，这张表保存了主键与索引字段，并指向实体表的记录（类似指针）。 索引优缺点优点 索引大大减小了服务器需要扫描的数据量 索引可以帮助服务器避免排序和临时表 索引可以将随机IO变成顺序IO 索引对于InnoDB（对索引支持行级锁）非常重要，InnoDB仅对需要访问的元组加锁，而索引能够减少InnoDB访问的元组数。如果查询不能使用索引，MySQL会进行全表扫描，并锁住每一个元组，不管是否真正需要。 缺点 虽然索引大大提高了查询速度，同时却会降低更新表的速度。因为更新表时，MySQL不仅要保存数据，还要保存索引文件。因此，对应更新非常频繁的字段，通常不建议使用索引。 建立索引会占用磁盘空间。 如果某个数据列包含许多重复的内容，为它建立索引效果就很差，这个性质称为索引的选择性：不重复的索引值和数据表中的记录总数的比值。索引的选择性越高则查询效率越高。比如对性别字段建立索引，一百万条数据，只有男女两种可能，索引选择性为五十万分之一，索引效果就很差 对于非常小的表，索引意义不大，大部分情况下简单的全表扫描更高效。 因此应该只为最经常查询和最经常排序的数据列建立索引。MySQL里同一个数据表里的索引总数限制为16个。 索引类型按功能逻辑划分从功能逻辑来划分，索引主要分为 普通索引、唯一索引、主键索引和全文索引 普通索引最基本的索引，它没有任何限制。普通索引（由关键字KEY或INDEX定义的索引）的唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件(WHERE column = …)或排序条件(ORDER BY column)中的数据列创建索引。 普通索引的创建有三种方式。 12345678910111213# 创建索引CREATE INDEX idx_username ON user_tbl(username);# 对于字符串字段，可以手动指定长度，如 user_tbl(username(5))，表示只用前五个字符来做索引，可以进一步加快查询效率，索引长度要小于字段长度# 修改表结构ALTER TABLE user_tbl ADD INDEX idx_username (username)# 创建表的时候直接指定，如CREATE TABLE user_tbl( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX idx_username (username) ); 删除索引 1DROP INDEX idx_username ON user_tbl; 查看索引 1SHOW INDEX FROM user_tbl; 唯一索引它与前面的普通索引类似，不同的就是：普通索引允许被索引的数据列包含重复的值。而唯一索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。 唯一索引的创建跟普通索引类似： 123456789101112#创建索引CREATE UNIQUE INDEX idx_username ON user_tbl(username);# 修改表结构ALTER TABLE user_tbl ADD UNIQUE idx_username (username)# 创建表的时候直接指定CREATE TABLE user_tbl( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE idx_username (username) ); 主键索引它是一种特殊的唯一索引，不允许有空值。一张表只能有一个主键，一般是在建表的时候同时创建。 12345CREATE TABLE user_tbl( ID INT NOT NULL, username VARCHAR(16) NOT NULL, PRIMARY KEY(ID) ); 与之类似的是外键索引，如果为某个外键字段定义了一个外键约束条件，MySQL就会定义一个内部索引来帮助自己以最有效率的方式去管理和使用外键约束条件。 全文索引在上一篇文章 MySQL 基础语法 中，我们说过如果使用了 LIKE + % 开头，就索引会失效，那么当我们需要前后都模糊搜索的需求（如 LIKE ‘%hello%’），就需要使用全文索引，需要注意的是，Innodb 只有在 5.6 版本之后才支持全文索引。 全文索引的创建和删除： 1234567# 创建的两种方法CREATE FULLTEXT INDEX idx_name ON tbl_name(field_name);ALTER TABLE tbl_name ADD FULLTEXT INDEX idx_name(field_name);# 删除的两种方法DROP INDEX idx_name ON tbl_name;ALTER TABLE tbl_name DROP INDEX idx_name; 使用全文索引进行全模糊匹配的语法为： 1234SELECT XXX FROM tbl_name WHERE match(field_name) against('xxx');# 比如对 user_tbl 的 user_name 字段加了全文索引# 查询结果等效于 SELECT user_name, user_id FROM user_tbl WHERE user_name LIKE '%hello%';SELECT user_name, user_id FROM user_tbl WHERE match(user_name) against('hello'); 使用 explain 检查，可以发现 fulltext 索引生效。 按物理实现划分按物理实现方式来划分，通常可以分为聚集索引和非聚集索引。 聚集索引（clustered index）存储内容是按照聚集索引排序的，聚集索引的顺序和行记录的顺序一致,一张表只能有一个聚集索引。聚集索引的叶子节点直接储存聚集索引指向的内容，因此查询的时候只需要进行一次查找。 聚集索引在创建主键时自动生成，如果没有主键，则根据第一个不为空的唯一索引自动生成，如果还没有，则自动生成一个隐式的聚集索引。 需要注意的是，在进行查询操作的时候，聚集索引的效率更高，因为少了一次查找；但是进行修改操作的时候，效率比非聚集索引低，因为直接修改了数据内容，为了标准数据内容的顺序和聚集索引顺序一致，会对数据页重新排序。 非聚集索引（non-clustered index）非聚集索引虽然索引项是顺序存储的，但是索引项对应的内容是随机存储的，系统会维护单独的索引表来存储索引。 非聚集索引的叶子节点存储的是数据的地址，查询非聚集索引的时候，系统会进行两次查找，先查找索引，再查找索引对应位置的数据。因此非聚集索引也叫二级索引或者辅助索引。 按字段个数划分按字段个数可以把索引分为单一索引和联合索引。 单一索引索引字段只有一列时为单一索引，上述所有索引都是单一索引。 联合索引将多个字段组合在一起创建的索引叫联合索引。如下： 1ALTER TABLE user_tbl ADD INDEX idx_name_city_age (username,city,age); 最左匹配原则建立这样的联合索引，其实是相当于分别建立了下面三组联合索引： 123usernname,city,ageusernname,cityusernname 为什么没有 city，age 这样的联合索引呢？这是因为MySQL联合索引的最左匹配原则，只会按照最左优先的顺序进行索引匹配，也就是说，(x,y,z) 和 (z,y,x) 是不同的索引，即使是使用联合索引中的字段查询，联合索引也有可能失效。 对于 (x,y,z)，只有在以下查询条件联合索引会生效： 123WHERE x = 1WHERE x = 1 AND y = 1WHERE x = 1 AND y = 1 AND z = 1 对于其他情况，比如 WHERE y = 1 、WHERE y = 1 AND z = 1 等，就不会匹配联合索引，索引失效，注意对于 WHERE x = 1 AND z = 1，联合索引会对 x 生效，但是对 z 不生效。 可以扩展了解一下，理论上最左匹配原则中索引对 where 中子句的顺序也是敏感的，但是由于MySQL的查询优化器会自动调整 where 子句的条件顺序以使用适合的索引，所以实际上 where 子句顺序不影响索引的效果。 要注意的是，如果联合索引查询过程中有范围查询，就会停止匹配，比如下面的语句中， z 字段不能使用到索引： 1WHERE x = 1 AND y &gt; 2 AND z = 3 顺便提一下，可以用 explain 命令来查看在某个查询语句中索引是否生效，具体用法请参考官网文档。 如果分别在 x, y, z 上建立单列索引，让该表有3个单列索引，索引效率也会大不一样，在联合索引生效的情况下，单个索引的效率远远低于联合索引。这是由 MySQL 查询优化器的执行顺序决定的，在执行一条查询 sql 时，针对索引的选择大致有如下步骤： MySQL 优化器根据搜索条件，找出所有可能使用的索引 计算全表扫描的代价 计算使用不同索引执行查询的代价 对比各种执行方案的代价，找出成本最低的那一个 因此，虽然有多个单列索引，但 MySQL 只能用到其中的那个系统认为似乎是最有效率的，其他的就会失效。 按索引结构划分不同的 mysql 数据引擎支持不同结构的索引，按结构划分，常用的索引为 B+树索引、Hash 索引、FULLTEXT索引 等，将在下一篇文章 MySQL 索引结构 中介绍。 使用总结接下来我们来简单总结一下在什么场景下推荐使用索引。 推荐使用 WHERE, GROUP BY, ORDER BY 子句中的字段 多个单列索引在多条件查询是只会有一个最优的索引生效，因此多条件查询中最好创建联合索引。 联合索引的时候必须满足最左匹配原则，并且最好考虑到 sql 语句的执行顺序，比如 WHERE a = 1 GROUP BY b ORDER BY c, 那么联合索引应该设计为 (a,b,c)，因为在上一篇文章 MySQL 基础语法 中我们介绍过，mysql 查询语句的执行顺序 WHERE &gt; GROUP BY &gt; ORDER BY。 多张表 JOIN 的时候，对表连接字段创建索引。 当 SELECT 中有不在索引中的字段时，会先通过索引查询出满足条件的主键值，然后通过主键回表查询出所有的 SELECT 中的字段，影响查询效率。因此如果 SELECT 中的内容很少，为了避免回表，可以把 SELECT 中的字段都加到联合索引中，这也就是宽索引的概念。但是需要注意，如果索引字段过多，存储和维护索引的成本也会增加。 不推荐使用或索引失效情况 数据量很小的表 有大量重复数据的字段 频繁更新的字段 如果对索引字段使用了函数或者表达式计算，索引失效 innodb OR 条件没有对所有条件创建索引，索引失效 大于小于条件 &lt; &gt;，索引是否生效取决于命中的数量比例，如果命中数量很多，索引生效，命中数量很小，索引失效 不等于条件 != &lt;&gt;，索引失效 LIKE 值以 % 开头，索引失效","link":"/2021/11/30/MySQL-%E7%B4%A2%E5%BC%95%E6%A6%82%E8%A7%88/"},{"title":"Mysql备忘","text":"Mysql权限 权限分布 可设置权限 表权限 ‘Select’, ‘Insert’, ‘Update’, ‘Delete’, ‘Create’, ‘Drop’, ‘Grant’, ‘References’, ‘Index’, ‘Alter’ 列权限 ‘Select’, ‘Insert’, ‘Update’, ‘References’ 过程权限 ‘Execute’, ‘Alter Routine’, ‘Grant’ 用户操作12345678910111213141516171819# 新增用户CREATE USER 'zhangsan'@'localhost' IDENTIFIED BY 'password';CREATE USER 'zhangsan'@'%' IDENTIFIED BY 'password2';CREATE USER 'zhangsan'@'192.168.10.1' IDENTIFIED BY 'password3';# 删除用户drop user zhangsan@'localhost';# 修改用户密码-- 第一种ALTER USER 'zhangsan'@'localhost' IDENTIFIED BY 'mypassword';-- 第二种SET PASSWORD FOR 'zhangsan'@'localhost' = PASSWORD('mypassword');-- 第三种GRANT USAGE ON *.* TO 'zhangsan'@'localhost' IDENTIFIED BY 'mypassword';# list所有用户select * from mysql.user\\G;# 同理可以通过sql语句修改用户信息或者删除用户 授权12345678910111213141516# 查看当前用户权限show grants;# 查看指定用户权限show grants for 'zhangsan'@'%'; # 赋予所有权限grant all privileges on *.* to 'zhangsan'@'%' with grant option;# 赋予数据库权限grant all privileges on test_db.* to 'zhangsan'@'%' with grant option;# 回收权限revoke all privileges ON *.* FROM admin@'localhost';revoke insert,select,update,delete,drop,create,alter on test_db.* from admin@'%';# 刷新权限flush privileges; with grant option : 允许被授权的用户把得到的权限继续授给其它用户 其他1234# 查看主节点状态show master status\\G;# 查看从节点状态show slave status\\G; 导出SQL123456789101112131415# 导出整个数据库结构和数据mysqldump -h localhost -P3306 -uroot -p123456 database &gt; dump.sql#导出单个数据表结构和数据mysqldump -h localhost -P3306 -uroot -p123456 database table &gt; dump.sql#导出整个数据库结构（不包含数据）mysqldump -h localhost -P3306 -uroot -p123456 -d database &gt; dump.sql#导出单个数据表结构（不包含数据）mysqldump -h localhost -P3306 -uroot -p123456 -d database table &gt; dump.sql#mysqldump 备份导出数据排除某张表mysqldump -h localhost -P3306 -uroot -p123456 -d database table --ignore-table=dbname.tablename &gt; dump.sql mysql 8.0需要添加这一句 --column-statistics=0 ，不然会报错。","link":"/2021/10/20/Mysql%E5%A4%87%E5%BF%98/"},{"title":"Mysql读写分离","text":"什么是主从复制、读写分离？MySQL的主从复制和读写分离是一起出现的，目的是为了提升数据库的并发性能。 MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。 MySQL 的读写分离是指如果有三台MySQL，一台mater只负责写操作，两台salve只负责读操作。 主从复制、读写分离就是为了数据库能支持更大的并发。 随着业务量的扩展、如果是单机部署的MySQL，会导致I/O频率过高。采用主从复制、读写分离可以提高数据库的可用性。 主从复制主从复制的原理 1、当Master节点进行insert、update、delete操作时，会按顺序写入到binlog中。 2、salve从库连接master主库，Master有多少个slave就会创建多少个binlog dump线程。 3、当Master节点的binlog发生变化时，binlog dump 线程会通知所有的salve节点，并将相应的binlog内容推送给slave节点。 4、I/O线程接收到 binlog 内容后，将内容写入到本地的 relay-log。 5、SQL线程读取I/O线程写入的relay-log，并且根据 relay-log 的内容对从数据库做对应的操作。 如何实现主从复制目前有两台主机，一台是Master(192.168.10.214)，一台是Slave(192.168.10.227)。 master配置使用命令行进入mysql： mysql -u root -p 创建从库连接主库的账号并授权： 1234# 192.168.10.227是slave从机的IPGRANT REPLICATION SLAVE ON *.* to 'slave_user'@'192.168.10.227' identified by 'testpass';# 刷新权限FLUSH PRIVILEGES; 在/etc/my.cnf配置文件中添加以下配置： 12345678# 开启binloglog-bin=mysql-binserver-id=1# 需要同步的数据库，如果不配置则同步全部数据库binlog-do-db=test_db# binlog日志保留的天数，清除超过10天的日志# 防止日志文件过大，导致磁盘空间不足expire-logs-days=10 配置完成后重启数据库： service mysql restart 可以通过命令show master status\\G;查看当前binlog日志的信息。 123456*************************** 1. row *************************** File: mysql-bin.000005 Position: 80770 Binlog_Do_DB: test_db Binlog_Ignore_DB: Executed_Gtid_Set: Slave配置在/etc/my.cnf配置文件中添加以下配置： server-id=2 登录mysql： mysql -u root -p 运行sql： 1234567CHANGE MASTER TOMASTER_HOST='192.168.10.214', # 主机IPMASTER_USER='slave_user',MASTER_PASSWORD='testpass',MASTER_LOG_FILE='mysql-bin.000005',MASTER_LOG_POS=68737, # 这里是show master status;中的Positionmaster_port=3306; 然后启动slave： 12# 启动slave服务start slave; 启动完之后查看一下结果： 1show slave status\\G; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455*************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 192.168.10.214 Master_User: root Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000005 Read_Master_Log_Pos: 71914 Relay_Log_File: mysql-relay-bin.000002 Relay_Log_Pos: 3469 Relay_Master_Log_File: mysql-bin.000005 Slave_IO_Running: Yes Slave_SQL_Running: Yes Replicate_Do_DB: Replicate_Ignore_DB: Replicate_Do_Table: Replicate_Ignore_Table: Replicate_Wild_Do_Table: Replicate_Wild_Ignore_Table: Last_Errno: 0 Last_Error: Skip_Counter: 0 Exec_Master_Log_Pos: 71914 Relay_Log_Space: 3778 Until_Condition: None Until_Log_File: Until_Log_Pos: 0 Master_SSL_Allowed: No Master_SSL_CA_File: Master_SSL_CA_Path: Master_SSL_Cert: Master_SSL_Cipher: Master_SSL_Key: Seconds_Behind_Master: 0 Master_SSL_Verify_Server_Cert: No Last_IO_Errno: 0 Last_IO_Error: Last_SQL_Errno: 0 Last_SQL_Error: Replicate_Ignore_Server_Ids: Master_Server_Id: 2 Master_SSL_Crl: Master_SSL_Crlpath: Using_Gtid: No Gtid_IO_Pos: Replicate_Do_Domain_Ids: Replicate_Ignore_Domain_Ids: Parallel_Mode: conservative SQL_Delay: 0 SQL_Remaining_Delay: NULL Slave_SQL_Running_State: Slave has read all relay log; waiting for the slave I/O thread to update it Slave_DDL_Groups: 0Slave_Non_Transactional_Groups: 0 Slave_Transactional_Groups: 0 如果Slave_IO_Running和Slave_SQL_Running就是正常了。 这时可以测试下新增表或者插入数据，如果从库正常同步那就OK了。 读写分离实现了主从复制后，我们开始实现读写分离。 目前使用的架构是： 123Springboot: 1.5.13.RELEASEMybatis : 3.4.5Druid : 1.1.4 基于Spring的AbstractRoutingDataSource和Mybatis plugin来实现动态切换数据源。 配置首先我们先配置数据源，建议从库赋予只读权限，因为从库不能更改： 123456789datasource.master.driver-class-name=com.mysql.jdbc.Driverdatasource.master.url=jdbc:mysql://192.168.10.214:3306/youbangdatasource.master.username=rootdatasource.master.password=datasource.slave0.driver-class-name=com.mysql.jdbc.Driverdatasource.slave0.url=jdbc:mysql://192.168.10.186:3306/youbangdatasource.slave0.username=rootdatasource.slave0.password= 读取配置12345678910111213141516@Configurationpublic class DataSourcePropertiesConfig { @Primary @Bean(&quot;masterDataSourceProperties&quot;) @ConfigurationProperties(&quot;datasource.master&quot;) public DataSourceProperties masterDataSourceProperties() { return new DataSourceProperties(); } @Bean(&quot;slave0DataSourceProperties&quot;) @ConfigurationProperties(&quot;datasource.slave0&quot;) public DataSourceProperties slave0DataSourceProperties() { return new DataSourceProperties(); }} 实现AbstractRoutingDataSourceSpring提供了AbstractRoutingDataSource，提供了动态选择数据源的功能，替换原有的单一数据源后，即可实现读写分离: 1234567891011121314151617181920212223242526272829303132333435363738@Componentpublic class CustomRoutingDataSource extends AbstractRoutingDataSource { @Resource(name = &quot;masterDataSourceProperties&quot;) private DataSourceProperties masterProperties; @Resource(name = &quot;slave0DataSourceProperties&quot;) private DataSourceProperties slave0Properties; @Override public void afterPropertiesSet() { DataSource masterDataSource = masterProperties.initializeDataSourceBuilder().type(DruidDataSource.class).build(); DataSource slave0DataSource = slave0Properties.initializeDataSourceBuilder().type(DruidDataSource.class).build(); setDefaultTargetDataSource(masterDataSource); Map&lt;Object, Object&gt; dataSourceMap = new HashMap&lt;&gt;(); dataSourceMap.put(DataSourceHolder.MASTER_DATASOURCE, masterDataSource); dataSourceMap.put(DataSourceHolder.SLAVE0_DATASOURCE, slave0DataSource); setTargetDataSources(dataSourceMap); super.afterPropertiesSet(); } @Override protected Object determineCurrentLookupKey() { String key = DataSourceHolder.getDataSource(); if (key == null) { // default datasource return DataSourceHolder.MASTER_DATASOURCE; } return key; } AbstractRoutingDataSource内部维护了一个Map&lt;Object, Object&gt;的Map初始话时，将master、slave两个数据源加入到这个map调用数据源时，determineCurrentLookupKey()方法返回了需要使用的数据源对应的key 当前线程需要使用的数据源对应的key，在DataSourceHolder中维护： 1234567891011121314151617181920public class DataSourceHolder { public static final String MASTER_DATASOURCE = &quot;master&quot;; public static final String SLAVE0_DATASOURCE = &quot;slave0&quot;; private static final ThreadLocal&lt;String&gt; local = new ThreadLocal&lt;&gt;(); public static void putDataSource(String dataSource) { local.set(dataSource); } public static String getDataSource() { return local.get(); } public static void clearDataSource() { local.remove(); }} 实现Mybatis Plugins当调用的Sql时Select类型时，将数据源切换到slave，其他情况数据源使用master； 注意，如果处于事务中，数据源只使用master，保持数据一致性 1234567891011121314151617181920212223242526272829303132333435@Intercepts({ @Signature(type = Executor.class, method = &quot;update&quot;, args = {MappedStatement.class, Object.class}), @Signature(type = Executor.class, method = &quot;query&quot;, args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}), @Signature(type = Executor.class, method = &quot;query&quot;, args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class})})public class MybatisDataSourceInterceptor implements Interceptor { @Override public Object intercept(Invocation invocation) throws Throwable { boolean synchronizationActive = TransactionSynchronizationManager.isSynchronizationActive(); if(!synchronizationActive) { Object[] objects = invocation.getArgs(); MappedStatement ms = (MappedStatement) objects[0]; if (ms.getSqlCommandType().equals(SqlCommandType.SELECT)) { DataSourceHolder.putDataSource(DataSourceHolder.SLAVE0_DATASOURCE); } } return invocation.proceed(); } @Override public Object plugin(Object target) { return Plugin.wrap(target, this); } @Override public void setProperties(Properties properties) { }} 在SqlSessionFactoryBean中新增插件： 123456789101112@Bean public SqlSessionFactory sqlSessionFactoryBean(DataSource dataSource) throws Exception { SqlSessionFactoryBean factory = new SqlSessionFactoryBean(); factory.setDataSource(dataSource); factory.setTypeAliasesPackage(MODEL_PACKAGE); MybatisDataSourceInterceptor mybatisDataSourceInterceptor = new MybatisDataSourceInterceptor(); //添加插件 factory.setPlugins(new Interceptor[]{mybatisDataSourceInterceptor}); return factory.getObject(); } 这里可以验证一下是否写操作走master，读操作走slave，我这里是通过jmeter并发请求来测试。","link":"/2021/10/19/Mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"},{"title":"docker镜像加速","text":"对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件） 1234567{ &quot;registry-mirrors&quot;: [ &quot;https://dockerhub.azk8s.cn&quot;, &quot;https://reg-mirror.qiniu.com&quot; ]} 之后重新启动服务。 123$ sudo systemctl daemon-reload$ sudo systemctl restart docker","link":"/2021/10/22/docker%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/07/08/hello-world/"},{"title":"三门问题","text":"什么是三门问题三门问题（Monty Hall problem）亦称为蒙提霍尔问题、蒙特霍问题或蒙提霍尔悖论，大致出自美国的电视游戏节目Let’s Make a Deal。问题名字来自该节目的主持人蒙提·霍尔（Monty Hall）。参赛者会看见三扇关闭了的门，其中一扇的后面有一辆汽车，选中后面有车的那扇门可赢得该汽车，另外两扇门后面则各藏有一只山羊。当参赛者选定了一扇门，但未去开启它的时候，节目主持人开启剩下两扇门的其中一扇，露出其中一只山羊。主持人其后会问参赛者要不要换另一扇仍然关上的门。问题是：换另一扇门是否会增加参赛者赢得汽车的机率。如果严格按照上述的条件，那么答案是会。不换门的话，赢得汽车的几率是1/3。换门的话，赢得汽车的几率是2/3。 程序验证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int bingo = 0;int total = 1000000;// 改变选择for(int a=0;a&lt;total;a++){ LinkedList door = new LinkedList(); Random random = new Random(); int key = random.nextInt(3); for(int i = 0; i&lt;3; i++){ if(i == key){ door.add(&quot;car&quot;); }else { door.add(&quot;sheep&quot;); } } int choose = random.nextInt(3); door.remove(choose); door.add(choose,&quot;choose&quot;); int open; while (true){ open = random.nextInt(3); if(open != choose &amp;&amp; !door.get(open).equals(&quot;car&quot;)){ break; } } int finalChoose; while (true){ finalChoose = random.nextInt(3); if(finalChoose != choose &amp;&amp; finalChoose != open){ break; } } if (door.get(finalChoose).equals(&quot;car&quot;)){ bingo++; }}System.out.println(&quot;改变策略 P = &quot; + bingo + &quot;/&quot; + total);System.out.println(&quot;改变策略 P = &quot; + (bingo*1.0 / total));// 不改变选择bingo = 0;for(int a=0;a&lt;total;a++){ LinkedList door = new LinkedList(); Random random = new Random(); int key = random.nextInt(3); for(int i = 0; i&lt;3; i++){ if(i == key){ door.add(&quot;car&quot;); }else { door.add(&quot;sheep&quot;); } } int choose = random.nextInt(3); if (door.get(choose).equals(&quot;car&quot;)){ bingo++; }}System.out.println(&quot;不改变策略 P = &quot; + bingo + &quot;/&quot; + total);System.out.println(&quot;不改变策略 P = &quot; + (bingo*1.0 / total)); 运行结果： 1234改变策略 P = 666635/1000000改变策略 P = 0.666635不改变策略 P = 334133/1000000不改变策略 P = 0.334133 可见，换门的话，能拿奖的概率会高一点。","link":"/2021/12/15/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/"},{"title":"二叉树遍历","text":"123456789101112131415class TreeNode{ public String val; public TreeNode left; public TreeNode right; public TreeNode(String val) { this.val = val; } public TreeNode(String val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; }} 先序遍历上图中序遍历顺序：abdecfg 代码： 12345678 public static void preOrder(TreeNode root){ if (root == null){ return; } System.out.println(root.val); preOrder(root.left); preOrder(root.right);} 中序遍历上图中序遍历顺序：dbeafcg 代码： 123456789public static void inOrder(TreeNode root){ if (root == null){ return; } inOrder(root.left); System.out.println(root.val); inOrder(root.right) } 后序遍历上图后序遍历顺序：debfgca 代码： 12345678public static void postOrder(TreeNode root){ if (root == null){ return; } postOrder(root.left); postOrder(root.right); System.out.println(root.val);}","link":"/2021/12/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"},{"title":"从源码看PriorityQueue","text":"add/offer java.util.PriorityQueue#add 将指定元素插入此优先级队列。返回：true （由Collection.add指定）抛出：ClassCastException – 如果根据优先级队列的顺序无法将指定元素与当前在此优先级队列中的元素进行比较 NullPointerException – 如果指定的元素为空 12345// java.util.PriorityQueue#addpublic boolean add(E e) { return offer(e);} 进入offer -&gt; siftUp，直接看siftUp函数 siftUp java.util.PriorityQueue#siftUp 在位置 k 处插入项 x，通过将 x 向上提升树直到它大于或等于其父项或者是根来保持堆不变。 简化和加速强制和比较。 Comparable 和 Comparator 版本被分成不同的方法，这些方法在其他方面是相同的。 （类似于 siftDown。）参数：k - 要填补的位置 x - 要插入的项目 12345678// java.util.PriorityQueue#siftUpprivate void siftUp(int k, E x) { if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x);} 这里根据有无比较器再分为两个情况，无比较器时使用自然顺序排序（Comparable natural ordering）： siftUpComparable12345678910111213private void siftUpComparable(int k, E x) { // E或者它的父类必须实现了Comparable接口，不然会报ClassCastException Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x; while (k &gt; 0) { int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; if (key.compareTo((E) e) &gt;= 0) break; queue[k] = e; k = parent; } queue[k] = key;} 看这段代码，可以判断这里是一个小顶堆，每次元素进来，就和父节点比较（[parent = (k - 1) &gt;&gt;&gt; 1]这里可以找到父节点，(当前节点-1)/2），如果父节点大于新加节点，则交换值，然后再和父节点的父节点比较，以此类推。 poll12345678910111213// java.util.PriorityQueue#pollpublic E poll() { if (size == 0) return null; int s = --size; modCount++; E result = (E) queue[0]; E x = (E) queue[s]; queue[s] = null; if (s != 0) siftDown(0, x); return result;} 同理，出元素跟入的逻辑流程差不多，我们直接来到siftDown -&gt;siftDownComparable： 1234567891011121314151617private void siftDownComparable(int k, E x) { Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;)x; int half = size &gt;&gt;&gt; 1; // loop while a non-leaf while (k &lt; half) { int child = (k &lt;&lt; 1) + 1; // assume left child is least Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; ((Comparable&lt;? super E&gt;) c).compareTo((E) queue[right]) &gt; 0) c = queue[child = right]; if (key.compareTo((E) c) &lt;= 0) break; queue[k] = c; k = child; } queue[k] = key;} 这里把最后一个元素拿出来，重建小顶堆。","link":"/2021/12/22/%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9C%8BPriorityQueue/"},{"title":"使用Github Action来自动化构建Maven项目","text":"简介本文主要介绍如何把Github仓库中的Maven项目通过Github Action进行自动化构建后生成Jar包，接着拷贝到服务器进行部署。 服务器脚本 脚本application.sh用于启停应用: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#!/bin/bash# application jar's nameappDir=~/java_deployapplication=$(find $appDir -type f -name &quot;*.jar&quot;) ## determine existence of processus of applicationisExist(){ ## check pid pid=`ps -ef | grep ${application} | grep -v grep | awk '{print $2}'` ## if pid not exist return 0 else 1 if [ -z &quot;${pid}&quot; ]; then return 0 else return 1 fi}log=$appDir/application.log## start application in background and generate appDir/application.logfunction start(){ ## deermine existence of processus isExist ## if not running if [ $? -eq &quot;0&quot; ]; then echo &quot;Your ${application} is not running&quot; nohup java -jar $application --spring.profiles.active=test &gt; $log &amp; echo &quot;${application} startup success&quot; else echo &quot;${application} is running, pid=${pid} &quot; fi}## stop the processus applicationfunction stop(){ isExist ## if not exist - ok if [ $? -eq &quot;0&quot; ]; then echo &quot;${application} is not running&quot; else echo &quot;${application} is running, pid=${pid}, prepare kill it &quot; # if exist - kill the processus kill -9 ${pid} echo &quot;${application} has been successfully killed&quot; fi}## check statusfunction status(){ appPid=`ps -ef |grep java|grep $application |awk '{print $2}'` if [ -z $appPid ]; then echo -e &quot;Not running &quot; else echo -e &quot;Running [$appPid] &quot; fi}## restartfunction restart(){ stop start}## argcase &quot;$1&quot; in &quot;start&quot;) start ;; &quot;stop&quot;) stop ;; &quot;restart&quot;) restart ;; &quot;status&quot;) status ;; *) echo &quot;please enter the correct commands: &quot; echo &quot;such as : sh application.sh [ start | stop | restart |status ]&quot; ;;esac 配置仓库Setting –&gt; Secrets Key Value HOST 你的服务器地址 USERNAME SSH连接用户名 PASSWORD SSH连接密码 PORT SSH端口 Github Action12345678910111213141516171819202122232425262728293031323334353637name: Java CI with Maven &amp; Deployon: push: branches: [ master ]jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Setup java uses: actions/setup-java@v2 with: java-version: '8' distribution: 'adopt' - name: Build with Maven run: mvn clean package -Dmaven.test.skip=true - name: Deploy to Server uses: appleboy/scp-action@master with: host: ${{ secrets.HOST }} username: ${{ secrets.USERNAME }} password: ${{ secrets.PASSWORD }} port: ${{ secrets.PORT }} source: &quot;your project path/*.jar&quot; target: &quot;target path&quot; strip_components: 2 - name: Run SSH Command uses: appleboy/ssh-action@master with: host: ${{ secrets.HOST }} username: ${{ secrets.USERNAME }} password: ${{ secrets.PASSWORD }} port: ${{ secrets.PORT }} script: &quot;your path/application.sh restart&quot;","link":"/2021/07/10/%E4%BD%BF%E7%94%A8Github-Action%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BAMaven%E9%A1%B9%E7%9B%AE/"},{"title":"使用compression-webpack-plugin压缩静态资源","text":"简介由于前端静态资源太大，网络带宽太小，往往要加载很久才能出来，所以通过compression-webpack-plugin压缩静态资源，提升用户体验。 步骤 1、安装插件:npm install compression-webpack-plugin --save-dev 2、在vue.config.js配置插件: 123456789const webpackPlugins = []const CompressionPlugin = require('compression-webpack-plugin') webpackPlugins.push(new CompressionPlugin({ algorithm: 'gzip', test: /\\.js$|\\.html$|\\.css$/, // 需要压缩的文件类型 threshold: 10240, // 归档需要进行压缩的文件大小最小值，我这个是10K以上的进行压缩 deleteOriginalAssets: false, // 是否删除原文件 minRatio: 0.5 })) 3、configureWebpack中添加plugins 1234configureWebpack: { ........ plugins: webpackPlugins}, 4、配置Nginx: 12345location / { ........ gzip_static on;}","link":"/2021/09/08/%E4%BD%BF%E7%94%A8compression-webpack-plugin%E5%8E%8B%E7%BC%A9%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/"},{"title":"如何发布自己的Maven包","text":"前言在开发springboot starter的时候发现，如果写完的starter直接导入已有工程有些问题，还是要上传到maven然后通过maven引入比较规范，但是每次通过网页管理上传maven包太过麻烦，所以配置了一下通过idea直接deploy上私有仓库，下面记录一下过程。 新建Maven库 1、以管理员身份登录maven私服 2、Repository –&gt; Repositories –&gt; create Repositories选择maven2(hosted) –&gt; Version policy 根据需要选择Release 或 Snapshot IDEA配置maven settings 1、 右键pom –&gt; Maven –&gt; open ‘settings.xml’ 2、配置nexus的账号密码 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt; &lt;servers&gt; &lt;server&gt; &lt;id&gt;snapshot&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;devnexus@1234&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt;&lt;/settings&gt; 配置starter项目 1、pom中添加一下代码： 1234567&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;snapshot&lt;/id&gt; &lt;name&gt;snapshot&lt;/name&gt; &lt;url&gt;http://dev.cmitgf.com:28081/repository/snapshot/&lt;/url&gt; &lt;/repository&gt;&lt;/distributionManagement&gt; 部署 maven deploy即可。 如果你只需要安装在本地maven，只需要maven install","link":"/2021/10/22/%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84Maven%E5%8C%85/"},{"title":"通过Docker Compose来部署MinIO","text":"简介MinIO 是一个基于Apache License v2.0开源协议的对象存储服务。它兼容亚马逊S3云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等，而一个对象文件可以是任意大小，从几kb到最大5T不等。 MinIO是一个非常轻量的服务,可以很简单的和其他应用的结合，类似 NodeJS, Redis 或者 MySQL。 前提条件 您的机器已经安装docker及docker compose。 部署 docker-compose.yaml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576version: '3.7'# Settings and configurations that are common for all containersx-minio-common: &amp;minio-common image: minio/minio:RELEASE.2021-07-30T00-02-00Z command: server --console-address &quot;:9001&quot; http://minio{1...4}/data{1...2} expose: - &quot;9000&quot; - &quot;9001&quot; environment: MINIO_ROOT_USER: minio MINIO_ROOT_PASSWORD: minio123 healthcheck: test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:9000/minio/health/live&quot;] interval: 30s timeout: 20s retries: 3# starts 4 docker containers running minio server instances.# using nginx reverse proxy, load balancing, you can access# it through port 9000.services: minio1: &lt;&lt;: *minio-common hostname: minio1 volumes: - data1-1:/data1 - data1-2:/data2 minio2: &lt;&lt;: *minio-common hostname: minio2 volumes: - data2-1:/data1 - data2-2:/data2 minio3: &lt;&lt;: *minio-common hostname: minio3 volumes: - data3-1:/data1 - data3-2:/data2 minio4: &lt;&lt;: *minio-common hostname: minio4 volumes: - data4-1:/data1 - data4-2:/data2 nginx: image: nginx:1.19.2-alpine hostname: nginx volumes: - ./nginx.conf:/etc/nginx/nginx.conf:ro ports: - &quot;9000:9000&quot; - &quot;9001:9001&quot; depends_on: - minio1 - minio2 - minio3 - minio4## By default this config uses default local driver,## For custom volumes replace with volume driver configuration.volumes: data1-1: data1-2: data2-1: data2-2: data3-1: data3-2: data4-1: data4-2: nginx.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101user nginx;worker_processes auto;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events { worker_connections 4096;}http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] &quot;$request&quot; ' '$status $body_bytes_sent &quot;$http_referer&quot; ' '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'; access_log /var/log/nginx/access.log main; sendfile on; keepalive_timeout 65; # include /etc/nginx/conf.d/*.conf; upstream minio { server minio1:9000; server minio2:9000; server minio3:9000; server minio4:9000; } upstream console { ip_hash; server minio1:9001; server minio2:9001; server minio3:9001; server minio4:9001; } server { listen 9000; listen [::]:9000; server_name localhost; # To allow special characters in headers ignore_invalid_headers off; # Allow any size file to be uploaded. # Set to a value such as 1000m; to restrict file size to a specific value client_max_body_size 0; # To disable buffering proxy_buffering off; location / { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_connect_timeout 300; # Default is HTTP/1, keepalive is only enabled in HTTP/1.1 proxy_http_version 1.1; proxy_set_header Connection &quot;&quot;; chunked_transfer_encoding off; proxy_pass http://minio; } } server { listen 9001; listen [::]:9001; server_name localhost; # To allow special characters in headers ignore_invalid_headers off; # Allow any size file to be uploaded. # Set to a value such as 1000m; to restrict file size to a specific value client_max_body_size 0; # To disable buffering proxy_buffering off; location / { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-NginX-Proxy true; # This is necessary to pass the correct IP to be hashed real_ip_header X-Real-IP; proxy_connect_timeout 300; # Default is HTTP/1, keepalive is only enabled in HTTP/1.1 proxy_http_version 1.1; proxy_set_header Connection &quot;&quot;; chunked_transfer_encoding off; proxy_pass http://console; } }} 运行下面的命令 GNU/Linux and macOS 12docker-compose pulldocker-compose up or 1docker stack deploy --compose-file docker-compose.yaml minio Windows 12docker-compose.exe pulldocker-compose.exe up or 1Copydocker stack deploy --compose-file docker-compose.yaml minio 现在可以通过http://127.0.0.1:9000/访问MinIO server","link":"/2021/08/05/%E9%80%9A%E8%BF%87Docker-Compose%E6%9D%A5%E9%83%A8%E7%BD%B2MinIO/"},{"title":"通过Git统计代码的提交量","text":"项目中有时候需要统计代码量，可以通过Git来统计。 获取所有作者提交行数1git log --format='%aN' | sort -u | while read name; do echo -en &quot;$name\\t&quot;; git log --author=&quot;$name&quot; --pretty=tformat: --since ==2020-9-1 --until=2020-9-31 --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf &quot;added lines: %s, removed lines: %s, total lines: %s\\n&quot;, add, subs, loc }' -; done 获取所有作者提交行数（排除某些文件夹）1git log --format='%aN' | sort -u | while read name; do echo -en &quot;$name\\t&quot;; git log --author=&quot;$name&quot; --pretty=tformat: --numstat -- . &quot;:(exclude)kapok/code&quot; | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf &quot;added lines: %s, removed lines: %s, total lines: %s\\n&quot;, add, subs, loc }' -; done","link":"/2021/07/08/%E9%80%9A%E8%BF%87Git%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8F%90%E4%BA%A4%E9%87%8F/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Firewall","slug":"Firewall","link":"/tags/Firewall/"},{"name":"Centos","slug":"Centos","link":"/tags/Centos/"},{"name":"IDEA Keymap","slug":"IDEA-Keymap","link":"/tags/IDEA-Keymap/"},{"name":"IDEA Plugins","slug":"IDEA-Plugins","link":"/tags/IDEA-Plugins/"},{"name":"Crack","slug":"Crack","link":"/tags/Crack/"},{"name":"源码","slug":"源码","link":"/tags/%E6%BA%90%E7%A0%81/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"},{"name":"读写分离","slug":"读写分离","link":"/tags/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"GitHub Action","slug":"GitHub-Action","link":"/tags/GitHub-Action/"},{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"Docker Compose","slug":"Docker-Compose","link":"/tags/Docker-Compose/"},{"name":"MinIO","slug":"MinIO","link":"/tags/MinIO/"},{"name":"Git","slug":"Git","link":"/tags/Git/"}],"categories":[{"name":"开发","slug":"开发","link":"/categories/%E5%BC%80%E5%8F%91/"},{"name":"服务器","slug":"服务器","link":"/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"IDE","slug":"开发/IDE","link":"/categories/%E5%BC%80%E5%8F%91/IDE/"},{"name":"Java","slug":"开发/Java","link":"/categories/%E5%BC%80%E5%8F%91/Java/"},{"name":"Mysql","slug":"开发/Mysql","link":"/categories/%E5%BC%80%E5%8F%91/Mysql/"},{"name":"动态代理","slug":"开发/Java/动态代理","link":"/categories/%E5%BC%80%E5%8F%91/Java/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"name":"Docker","slug":"开发/Docker","link":"/categories/%E5%BC%80%E5%8F%91/Docker/"},{"name":"思考","slug":"思考","link":"/categories/%E6%80%9D%E8%80%83/"},{"name":"源码","slug":"开发/Java/源码","link":"/categories/%E5%BC%80%E5%8F%91/Java/%E6%BA%90%E7%A0%81/"},{"name":"算法","slug":"开发/算法","link":"/categories/%E5%BC%80%E5%8F%91/%E7%AE%97%E6%B3%95/"},{"name":"Github Action","slug":"开发/Github-Action","link":"/categories/%E5%BC%80%E5%8F%91/Github-Action/"},{"name":"webpack","slug":"开发/webpack","link":"/categories/%E5%BC%80%E5%8F%91/webpack/"},{"name":"Maven","slug":"开发/Java/Maven","link":"/categories/%E5%BC%80%E5%8F%91/Java/Maven/"},{"name":"Git","slug":"开发/Git","link":"/categories/%E5%BC%80%E5%8F%91/Git/"}]}